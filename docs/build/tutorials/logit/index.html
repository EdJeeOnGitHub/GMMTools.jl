<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Logit tutorial · GMMTools.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://Gkreindler.github.io/GMMTools.jl/stable/tutorials/logit/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">GMMTools.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li class="is-active"><a class="tocitem" href>Logit tutorial</a><ul class="internal"><li><a class="tocitem" href="#Set-up"><span>Set up</span></a></li><li><a class="tocitem" href="#Estimation-Strategy"><span>Estimation Strategy</span></a></li><li><a class="tocitem" href="#Setting-up-the-estimation"><span>Setting up the estimation</span></a></li><li><a class="tocitem" href="#Performing-the-estimation"><span>Performing the estimation</span></a></li><li><a class="tocitem" href="#Inspecting-the-output"><span>Inspecting the output</span></a></li><li><a class="tocitem" href="#Fine-tuning-the-optimization"><span>Fine-tuning the optimization</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Logit tutorial</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Logit tutorial</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Gkreindler/GMMTools.jl/blob/main/docs/src/tutorials/logit.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Estimating-a-logit-decision-model"><a class="docs-heading-anchor" href="#Estimating-a-logit-decision-model">Estimating a logit decision model</a><a id="Estimating-a-logit-decision-model-1"></a><a class="docs-heading-anchor-permalink" href="#Estimating-a-logit-decision-model" title="Permalink"></a></h1><p>This tutorial demonstrates how to use GMMTools.jl to estimate preference parameters in a simple binary choice model with a logit structure. </p><h2 id="Set-up"><a class="docs-heading-anchor" href="#Set-up">Set up</a><a id="Set-up-1"></a><a class="docs-heading-anchor-permalink" href="#Set-up" title="Permalink"></a></h2><p>A driver needs to go to work, and needs to choose between a short route with a toll and a longer, but free, route. The driver&#39;s utility is denominated in the currency (e.g. dollars). Relative utility between routes is a function of how much longer the long route takes to travel as well as any tolls a driver faces in the route. </p><p>We observe the decisions of many drivers. Our goal is to use this data to estimate underlying preference parameters of the driving population at large. </p><p>We use a field experiment helps us with this estimation. Approximately half of the agents are &quot;treated&quot; in an experiment where they face a fixed charge of using the shorter route. For the control group, both routes are free. Comparing the number of drivers who take the shorter route, conditional on distance, in treated and control groups teaches us about underlying preferences. </p><p>Let <span>$d_1$</span> be the short distance and <span>$d_2$</span> be the long distance. Define <span>$p$</span> as the price of the toll and <span>$T_i$</span> whether an individual is treated. Define the utilities of the short and long distance, respectively as</p><p class="math-container">\[U_{1i} = \alpha d_{1i} +  T_i p + \sigma \epsilon_{1i} \\
U_{2i} = \alpha d_{2i} + \sigma \epsilon_{2i}\]</p><p>In the model, the <span>$\epsilon$</span> shocks are Type I extreme-valued with variance parameter <span>$1$</span>. A driver chooses the shorter route (Route 1), when <span>$U_{1i} &gt; U_{2i}$</span> As a consequence of our assumptions, we know the probability an individual chooses the shorter route is</p><p class="math-container">\[\mathbf{P}(\text{Shorter route}_i) = \mathbf{P}\left(\frac{-\alpha |d_{2i} - d_{1i}| + T_i p}{\sigma} &gt; \epsilon_{2i} - \epsilon_{1i}\right)\]</p><p>Define <span>$\epsilon_{12_i} = \epsilon_{2i} - \epsilon_{1i}$</span>, which is distributed according to the logistic distribution such that</p><p class="math-container">\[\epsilon_{12} \sim \frac{e^{\epsilon_{12}}}{1 + e^{\epsilon_{12}}}\]</p><p>Define <span>$d$</span> as the difference between the long and short route, <span>$d = |d_2 - d_1|$</span>. Therefore, the probability someone chooses the shorter route can be re-written as</p><p class="math-container">\[\mathbf{P}(\text{Shorter route}_i \mid d_i, T_i) = \frac{\exp\left(\frac{-\alpha d_i + T_i p}{\sigma}\right)}{1 + \exp\left(\frac{-\alpha d + T_i p}{\sigma}\right)}\]</p><p>The unknown model parameters we will estimate are <span>$\alpha$</span>, the value of travel time, and <span>$\sigma$</span> the logit variance parameter. </p><h2 id="Estimation-Strategy"><a class="docs-heading-anchor" href="#Estimation-Strategy">Estimation Strategy</a><a id="Estimation-Strategy-1"></a><a class="docs-heading-anchor-permalink" href="#Estimation-Strategy" title="Permalink"></a></h2><p>We are presented with a data with <span>$N$</span> individuals, half are treated and half are not. We  observe the time and cost difference between their short and long routes as well as their choices. Our goal is to guess <span>$\theta = (\alpha, \sigma)$</span> such that a theoretical prediction of drivers&#39; choices best matches our observed data. </p><p>To show the strength of GMMTools, we will choose two moments which are  opaque functions of the data directly. These will be the model-predicted mean of take-up in the treated and control groups respectively. Define <span>$g$</span> to be the expected values of take-up for the control and treated groups according to the model described above. </p><p class="math-container">\[g(\theta) = \begin{bmatrix}
\frac{1}{N/2}\sum_{i \mid T_i = 0} \mathbf{P}(\text{Shorter route}_i \mid d_i, T_i)   \\
\frac{1}{N/2}\sum_{i \mid T_i = 0} \mathbf{P}(\text{Shorter route}_i \mid d_i, T_i) 
\end{bmatrix} \]</p><p class="math-container">\[\hat{g} = \begin{bmatrix}
\frac{1}{N_0}\sum_{i \mid T_i = 0} \text{Shorter route}_i  \\
\frac{1}{N_1}\sum_{i \mid T_i = 1} \text{Shorter route}_i
\end{bmatrix}\]</p><p>Define the anal</p><p>We select <span>$\hat{\theta}$</span> to minimize </p><p class="math-container">\[|| g(\hat{\theta}) - \hat{g}||\]</p><h2 id="Setting-up-the-estimation"><a class="docs-heading-anchor" href="#Setting-up-the-estimation">Setting up the estimation</a><a id="Setting-up-the-estimation-1"></a><a class="docs-heading-anchor-permalink" href="#Setting-up-the-estimation" title="Permalink"></a></h2><p>Load the packages we will be using for the analysis</p><pre><code class="language-julia hljs">using GMMTools
using Parameters
using UnPack
using GLM
using Random, Statistics, LinearAlgebra</code></pre><p>Define containers for the known parameters in the model (the inputs) and the unknown parameters in the model (which we will determine via calibration)</p><pre><code class="language-julia hljs">@with_kw struct KnownParams{T}
  p::T
end</code></pre><pre><code class="language-julia hljs">@with_kw struct UnKnownParams{T}
  α::T
  σ::T
end</code></pre><p>For a single individual, find <span>$\mathbf{P}(\text{Shorter route}_i \mid d_i, T_i)$</span>. We censor values to avoid numerical errors.</p><pre><code class="language-julia hljs">function get_indiv_pred_takeup(
  dist,
  treated,
  kp::KnownParams,
  up::UnKnownParams;
  max_diff = 200)

  @unpack α, σ = up
  @unpack p = kp
  inside_exp = (-α * dist + treated * p) / σ
  t = clamp(inside_exp, -max_diff, max_diff)
  e = exp(t)
  e / (1 + e)
end</code></pre><p>We use the function above to now calculate <span>$g(\hat{\theta})$</span>. We return a <span>$1\times 2$</span> matrix, in accordance with the expectations of the GMMTools.jl API.   </p><pre><code class="language-julia hljs">function get_moments_model(up::UnKnownParams, data, kp::KnownParams)
  @unpack treatments, distances, takeups = data
  treated_obs = treatments .== 1
  control_obs = treatments .== 0
  # Get treated and control takeup means predicted by model
  pred_takeup = get_indiv_pred_takeup.(data.distances, data.treatments, Ref(kp), Ref(up))

  [mean(pred_takeup[control_obs]) mean(pred_takeup[treated_obs])]
end</code></pre><p>In the third step, we calculate <span>$\hat{g}$</span>, the observed means of take-up between treated and control groups. We also return the variance-covariance matrix of <span>$\hat{g}$</span>, which we will use later in estimation. </p><pre><code class="language-julia hljs">function get_moments_data(data)
  # Get treated and control takeup means
  # By omitting the intersection and including the (perfectly)
  # collinear) vector of who is a control, coefficients represent
  # group means.
  m = lm(@formula(takeups ~ 0 + controls + treatments), data)
  M = permutedims(coef(m))

  # The covariance matrix is now easily estimated from the
  # regression output
  V = vcov(m)

  M, V
end</code></pre><p>Putting the above together, we estimate </p><p class="math-container">\[||g(\hat{\theta}) - \hat{g} ||\]</p><pre><code class="language-julia hljs">function get_moments_diff(up::UnKnownParams, data, kp::KnownParams)
  M_data, V_data = get_moments_data(data)
  M_model = get_moments_model(up, data, kp)

  M_model .- M_data
end</code></pre><p>Finally, we define a small function to generate the data so that we can perform the estimation. We input a random number generator to this function for reproducibility. </p><pre><code class="language-julia hljs">function generate_data(;
  N,
  max_distance,
  kp::KnownParams,
  true_up::UnKnownParams, # Actually known, here
  rng = nothing)

  distances = rand(rng, N) .* max_distance
  treatments = rand(rng, N).&lt; .5
  controls = treatments .== 0

  takeup_probs = get_indiv_pred_takeup.(distances, treatments, Ref(kp), Ref(true_up))
  takeups = rand(rng, N) .&lt; takeup_probs

  (; distances, treatments, controls, takeups)
end</code></pre><h2 id="Performing-the-estimation"><a class="docs-heading-anchor" href="#Performing-the-estimation">Performing the estimation</a><a id="Performing-the-estimation-1"></a><a class="docs-heading-anchor-permalink" href="#Performing-the-estimation" title="Permalink"></a></h2><p>First, generate data according to the true parameters. </p><pre><code class="nohighlight hljs">rng = MersenneTwister(123)

kp = KnownParams(p = 10.0)

true_up = UnKnownParams(α = 1.5, σ = 10.0)

data = generate_data(;
  N = 50000,
  kp,
  max_distance = 20,
  true_up, 
  rng)</code></pre><p>Now we finally use the GMMTools.jl library to estimate our unknown parameters. To do this we use the function <code>run_estimation</code>. <code>run_estimation</code> takes the following arguments:</p><ul><li><code>momfn</code>: The moment function, used in the form <code>momfn(theta, data)</code> where <code>theta</code> is a vector of parameters to be estimated.</li><li><code>data</code>: The object passed to <code>momfn</code></li><li><code>theta0</code>: Matrix representing starting guesses of <code>theta</code>. It is of size <code>main_n_start_pts</code> x <code>n_params</code> where <code>main_n_start_pts</code> is taken from the dictionary containing gmm options. <code>n_params</code> is the length of <code>theta</code>.</li><li><code>theta0_boot</code>: Akin to <code>theta0</code>, but contains starting values for each bootstrapping iteration. It is of size (<code>boot_n_start_pts</code> x <code>boot_n_runs</code>) x <code>n_params</code></li><li><code>theta_lower</code>: Vector of lower bounds (default is -Inf)</li><li><code>theta_upper</code>: vector of upper bounds (default is +Inf)</li></ul><p>First, we define <code>momfn</code> according to the requirements above</p><pre><code class="nohighlight hljs">moment_fun = let kp = kp # Capture the known parameters
  (θ, data) -&gt; begin
    up = UnKnownParams(α = θ[1], σ = θ[2])
    get_moments_diff(up, data, kp)
  end
end</code></pre><p>Confirm that the moment function returns the correct <span>$1 \times 2$</span> matrix</p><pre><code class="language-julia hljs">moment_fun([1, 2], data)</code></pre><p>Next, we define the GMM options that will control details of our estimation</p><pre><code class="nohighlight hljs">output_dir = mktempdir()
gmm_options = Dict{String, Any}(
  # Do not run the estimation in parallel
  &quot;main_run_parallel&quot; =&gt; false,

  # Use a minimum distance estimator, rather than a 
  # GMM estimator. 
  &quot;estimator&quot; =&gt; &quot;cmd&quot;,

  # Re-run the estimation when we calculate standard
  # errors, rather than re-use original parameter 
  # estimates
  &quot;var_boot&quot; =&gt; &quot;slow&quot;,
  &quot;boot_n_runs&quot; =&gt; 5,

  # Folder to store intermediate output 
  &quot;rootpath_output&quot; =&gt; output_dir,  

  # Write intermediate parameter estimation
  # to a file
  &quot;main_write_results_to_file&quot; =&gt; true,

  # Do not write the bootstrapping to file
  &quot;boot_write_results_to_file&quot; =&gt; false,

  # Print out progress in estimation of θ
  &quot;show_progress&quot; =&gt; true,
  
  # Do not show progress for bootstrapping
  &quot;boot_show_progress&quot; =&gt; false,

  # Overwrite results
  &quot;main_overwrite_runs&quot; =&gt; 10, ## 10=overwrite everything
  &quot;boot_overwrite_runs&quot; =&gt; 10, ## 10=overwrite everything

  # Throw errors during estimation of θ
  &quot;main_throw_errors&quot; =&gt; true,

  # Do not throw errors during bootstrapping
  &quot;boot_throw_errors&quot; =&gt; false
)</code></pre><p>Finally we are ready to run the estimation using the <code>run_estimation</code> function from GMMTools.jl</p><pre><code class="language-julia hljs"># Initial guess of θ
θ_0 = [1.5 10.0]
res = run_estimation(;
  momfn = moment_fun,
  data = data,
  theta0 = θ_0,
  theta_lower = [0.0, 0.0],
  theta_upper = [Inf, Inf],
  # Use the identity matrix to weight
  omega = I,
  gmm_options)</code></pre><h2 id="Inspecting-the-output"><a class="docs-heading-anchor" href="#Inspecting-the-output">Inspecting the output</a><a id="Inspecting-the-output-1"></a><a class="docs-heading-anchor-permalink" href="#Inspecting-the-output" title="Permalink"></a></h2><p>The output <code>res</code> gives two objects, a <code>DataFrame</code> storing the minimum distance, best parameters, etc. and a <code>Dict</code> showing errors which may have occurred in the estimation.</p><pre><code class="language-julia hljs">res_df, res_dict = res</code></pre><p>Inspecting <code>res_df.param_1</code> and <code>res_df.param_2</code>, we get the values </p><p class="math-container">\[\hat{\alpha} = 1.510 \\
\hat{\sigma} = 9.972\]</p><p>The optimizer was able to get close to the true values of <span>$\alpha = 1.5$</span> and <span>$\sigma = 10$</span>. </p><p>Inspecting <code>res_dict</code> shows there were no errors and no non-convergences during estimation. </p><p>These the results that exist in the Julia session. But GMMTools.jl also saves results to files. Let&#39;s inspect these individually. They are stored in <code>output_dir</code>, which we passed to the <code>gmm_options</code> dictionary above.</p><pre><code class="nohighlight hljs">files = readdir(output_dir)
readshow(f) = println(read(joinpath(output_dir, f), String))</code></pre><pre><code class="nohighlight hljs">3-element Vector{String}:
 &quot;estimation_flags.json&quot;
 &quot;estimation_parameters.json&quot;
 &quot;estimation_results_df.csv&quot;</code></pre><pre><code class="language-julia hljs">readshow(&quot;estimation_flags.json&quot;)</code></pre><pre><code class="nohighlight hljs">{
    &quot;n_success&quot;: 1,
    &quot;n_errors&quot;: 0,
    &quot;n_not_converged&quot;: 0
}</code></pre><p>This corresponds to <code>res_d</code></p><pre><code class="language-julia hljs">readshow(&quot;estimation_parameters.json&quot;)</code></pre><pre><code class="nohighlight hljs">{
    &quot;gmm_options&quot;: {
        &quot;rootpath_output&quot;: &quot;/tmp/jl_I6JkzR&quot;,
        &quot;use_unconverged_results&quot;: false,
        &quot;var_boot&quot;: &quot;slow&quot;,
        &quot;boot_maxIter&quot;: 1000,
        &quot;main_show_theta&quot;: false,
        &quot;main_throw_errors&quot;: true,
        &quot;main_write_results_to_file&quot;: true,
        &quot;boot_overwrite_runs&quot;: 10,
        &quot;main_maxIter&quot;: 1000,
        &quot;boot_throw_errors&quot;: false,
        &quot;estimator&quot;: &quot;cmd&quot;,
        &quot;n_params&quot;: 2,
        &quot;main_maxTime&quot;: null,
        &quot;n_moms_full&quot;: 2,
        &quot;boot_maxTime&quot;: null,
        &quot;boot_show_progress&quot;: false,
        &quot;main_show_trace&quot;: false,
        &quot;boot_n_runs&quot;: 5,
        &quot;boot_write_results_to_file&quot;: true,
        &quot;show_progress&quot;: true,
        &quot;var_asy&quot;: true,
        &quot;boot_run_parallel&quot;: false,
        &quot;2step&quot;: false,
        &quot;main_n_initial_cond&quot;: 1,
        &quot;normalize_weight_matrix&quot;: false,
        &quot;boot_show_theta&quot;: false,
        &quot;main_run_parallel&quot;: false,
        &quot;boot_show_trace&quot;: false,
        &quot;main_overwrite_runs&quot;: 10,
        &quot;n_moms&quot;: 2,
        &quot;n_observations&quot;: 1,
        &quot;param_names&quot;: null
    },
    &quot;W&quot;: [
        [
            1.0,
            0.0
        ],
        [
            0.0,
            1.0
        ]
    ],
    &quot;theta0&quot;: [
        [
            1.5
        ],
        [
            10.0
        ]
    ],
    &quot;main_n_initial_cond&quot;: 1,
    &quot;theta_fix&quot;: null,
    &quot;n_moms&quot;: 2,
    &quot;n_params&quot;: 2,
    &quot;theta_upper&quot;: [
        null,
        null
    ],
    &quot;theta_lower&quot;: [
        0.0,
        0.0
    ],
    &quot;n_moms_full&quot;: 2,
    &quot;moms_subset&quot;: null,
    &quot;omega&quot;: {
        &quot;λ&quot;: true
    },
    &quot;n_observations&quot;: 1
}</code></pre><p>This corresponds to the full set of inputs to the key function <code>run_estimation</code>. Reading this file back in will let us fully reproduce our original estimation procedure. </p><pre><code class="language-julia hljs">readshow(&quot;estimation_results_df.csv&quot;)</code></pre><pre><code class="nohighlight hljs">obj_vals,opt_converged,opt_error,opt_error_message,opt_runtime,param_1,param_2,run_idx,is_optimum
1.277058133722624e-15,true,false,,0.498569576,1.5101382430140904,9.971757744026124,1,true</code></pre><p>This corresponds to <code>res_df</code>, which holds the parameter estimates. </p><h2 id="Fine-tuning-the-optimization"><a class="docs-heading-anchor" href="#Fine-tuning-the-optimization">Fine-tuning the optimization</a><a id="Fine-tuning-the-optimization-1"></a><a class="docs-heading-anchor-permalink" href="#Fine-tuning-the-optimization" title="Permalink"></a></h2><h3 id="Using-GMM-estimation"><a class="docs-heading-anchor" href="#Using-GMM-estimation">Using GMM estimation</a><a id="Using-GMM-estimation-1"></a><a class="docs-heading-anchor-permalink" href="#Using-GMM-estimation" title="Permalink"></a></h3><p>Here we perform a one-step GMM estimation, equivalent to solving</p><p class="math-container">\[\min_{\theta} (\hat{g} - g(\hat{\theta}))&#39; \Omega^{-1} (\hat{g} - g(\hat{\theta})\]</p><p>Where <span>$\Omega$</span> represents the variance-covariance matrix of <span>$\hat{g} - g(\hat{\theta})$</span>. For our purposes, we use the variance-covariance matrix of <span>$\hat{g}$</span>, calculated with <code>get_moments_data</code></p><pre><code class="language-julia hljs">_, V = get_moments_data(data)

gmm_options_one_step = let 
  t = copy(gmm_options)
  t[&quot;estimator&quot;] = &quot;gmm1step&quot;
  t
end

res_one_step = run_estimation(;
  momfn = moment_fun,
  data = data,
  theta0 = θ_0,
  theta_lower = [0.0, 0.0],
  theta_upper = [Inf, Inf],
  # Use the identity matrix to weight
  omega = V,
  gmm_options = gmm_options_one_step)

res_one_step_df, res_one_step_d = res_one_step</code></pre><h3 id="Multiple-initial-conditions"><a class="docs-heading-anchor" href="#Multiple-initial-conditions">Multiple initial conditions</a><a id="Multiple-initial-conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Multiple-initial-conditions" title="Permalink"></a></h3><p>Often, the function we are minimizing has many local minima. To ensure we are finding the global minimum, is is helpful to use random initial conditions. We do this with the <code>random_initial_conditions</code> function. </p><pre><code class="language-julia hljs">θ_0 = [1.5 10.0]

θ_0s_random = random_initial_conditions(θ_0, [0, 0], [Inf, Inf], 100)

res_random = run_estimation(;
  momfn = moment_fun,
  data = data,
  theta0 = θ_0s_random,
  theta_lower = [0.0, 0.0],
  theta_upper = [Inf, Inf],
  # Use the identity matrix to weight
  omega = I,
  gmm_options)

res_random_df, res_random_d = res_random</code></pre><h3 id="Running-in-parallel-with-multiple-initial-conditions"><a class="docs-heading-anchor" href="#Running-in-parallel-with-multiple-initial-conditions">Running in parallel with multiple initial conditions</a><a id="Running-in-parallel-with-multiple-initial-conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Running-in-parallel-with-multiple-initial-conditions" title="Permalink"></a></h3><p>When we optimize with various initial conditions, these processes are entirely independent and can thus occur in parallel. </p><pre><code class="language-julia hljs">θ_0 = [1.5 10.0]

θ_0s_random = random_initial_conditions(θ_0, [0, 0], [Inf, Inf], 100)

gmm_options_parallel = let 
  t = copy(gmm_options)
  t[&quot;main_run_parallel&quot;] = true
  t
end

res_parallel = run_estimation(;
  momfn = moment_fun,
  data = data,
  theta0 = θ_0s_random,
  theta_lower = [0.0, 0.0],
  theta_upper = [Inf, Inf],
  # Use the identity matrix to weight
  omega = I,
  gmm_options)

res_parallel_df, res_parallel_d = res_parallel</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">« Introduction</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Monday 27 February 2023 15:39">Monday 27 February 2023</span>. Using Julia version 1.8.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
